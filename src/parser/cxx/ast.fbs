// Copyright (c) 2023 Roberto Raggi <roberto.raggi@gmail.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

namespace cxx.io;

table SourceLine {
  file_name: string;
  line: uint32;
}

table SourceLocation {
  source_line: SourceLine;
  column: uint32;
}

union AST {
  GlobalModuleFragment,
  PrivateModuleFragment,
  ModuleDeclaration,
  ModuleName,
  ModuleQualifier,
  ModulePartition,
  ImportName,
  InitDeclarator,
  Declarator,
  UsingDeclarator,
  Enumerator,
  TypeId,
  Handler,
  BaseSpecifier,
  RequiresClause,
  ParameterDeclarationClause,
  TrailingReturnType,
  LambdaSpecifier,
  TypeConstraint,
  AttributeArgumentClause,
  Attribute,
  AttributeUsingPrefix,
  NewPlacement,
  NestedNamespaceSpecifier,
}

union AttributeSpecifier {
  CxxAttribute,
  GccAttribute,
  AlignasAttribute,
  AsmAttribute,
}

union AttributeToken {
  ScopedAttributeToken,
  SimpleAttributeToken,
}

union CoreDeclarator {
  BitfieldDeclarator,
  ParameterPack,
  IdDeclarator,
  NestedDeclarator,
}

union Declaration {
  SimpleDeclaration,
  AsmDeclaration,
  NamespaceAliasDefinition,
  UsingDeclaration,
  UsingEnumDeclaration,
  UsingDirective,
  StaticAssertDeclaration,
  AliasDeclaration,
  OpaqueEnumDeclaration,
  FunctionDefinition,
  TemplateDeclaration,
  ConceptDefinition,
  DeductionGuide,
  ExplicitInstantiation,
  ExportDeclaration,
  ExportCompoundDeclaration,
  LinkageSpecification,
  NamespaceDefinition,
  EmptyDeclaration,
  AttributeDeclaration,
  ModuleImportDeclaration,
  ParameterDeclaration,
  AccessDeclaration,
  ForRangeDeclaration,
  StructuredBindingDeclaration,
  AsmOperand,
  AsmQualifier,
  AsmClobber,
  AsmGotoLabel,
}

union DeclaratorChunk {
  FunctionDeclaratorChunk,
  ArrayDeclaratorChunk,
}

union ExceptionDeclaration {
  EllipsisExceptionDeclaration,
  TypeExceptionDeclaration,
}

union ExceptionSpecifier {
  ThrowExceptionSpecifier,
  NoexceptSpecifier,
}

union Expression {
  CharLiteralExpression,
  BoolLiteralExpression,
  IntLiteralExpression,
  FloatLiteralExpression,
  NullptrLiteralExpression,
  StringLiteralExpression,
  UserDefinedStringLiteralExpression,
  ThisExpression,
  NestedExpression,
  IdExpression,
  LambdaExpression,
  FoldExpression,
  RightFoldExpression,
  LeftFoldExpression,
  RequiresExpression,
  SubscriptExpression,
  CallExpression,
  TypeConstruction,
  BracedTypeConstruction,
  MemberExpression,
  PostIncrExpression,
  CppCastExpression,
  TypeidExpression,
  TypeidOfTypeExpression,
  UnaryExpression,
  AwaitExpression,
  SizeofExpression,
  SizeofTypeExpression,
  SizeofPackExpression,
  AlignofTypeExpression,
  AlignofExpression,
  NoexceptExpression,
  NewExpression,
  DeleteExpression,
  CastExpression,
  ImplicitCastExpression,
  BinaryExpression,
  ConditionalExpression,
  YieldExpression,
  ThrowExpression,
  AssignmentExpression,
  PackExpansionExpression,
  DesignatedInitializerClause,
  TypeTraitsExpression,
  ConditionExpression,
  EqualInitializer,
  BracedInitList,
  ParenInitializer,
}

union FunctionBody {
  DefaultFunctionBody,
  CompoundStatementFunctionBody,
  TryStatementFunctionBody,
  DeleteFunctionBody,
}

union LambdaCapture {
  ThisLambdaCapture,
  DerefThisLambdaCapture,
  SimpleLambdaCapture,
  RefLambdaCapture,
  RefInitLambdaCapture,
  InitLambdaCapture,
}

union MemInitializer {
  ParenMemInitializer,
  BracedMemInitializer,
}

union NestedNameSpecifier {
  GlobalNestedNameSpecifier,
  SimpleNestedNameSpecifier,
  DecltypeNestedNameSpecifier,
  TemplateNestedNameSpecifier,
}

union NewInitializer {
  NewParenInitializer,
  NewBracedInitializer,
}

union PtrOperator {
  PointerOperator,
  ReferenceOperator,
  PtrToMemberOperator,
}

union Requirement {
  SimpleRequirement,
  CompoundRequirement,
  TypeRequirement,
  NestedRequirement,
}

union Specifier {
  TypedefSpecifier,
  FriendSpecifier,
  ConstevalSpecifier,
  ConstinitSpecifier,
  ConstexprSpecifier,
  InlineSpecifier,
  StaticSpecifier,
  ExternSpecifier,
  ThreadLocalSpecifier,
  ThreadSpecifier,
  MutableSpecifier,
  VirtualSpecifier,
  ExplicitSpecifier,
  AutoTypeSpecifier,
  VoidTypeSpecifier,
  SizeTypeSpecifier,
  SignTypeSpecifier,
  VaListTypeSpecifier,
  IntegralTypeSpecifier,
  FloatingPointTypeSpecifier,
  ComplexTypeSpecifier,
  NamedTypeSpecifier,
  AtomicTypeSpecifier,
  UnderlyingTypeSpecifier,
  ElaboratedTypeSpecifier,
  DecltypeAutoSpecifier,
  DecltypeSpecifier,
  PlaceholderTypeSpecifier,
  ConstQualifier,
  VolatileQualifier,
  RestrictQualifier,
  EnumSpecifier,
  ClassSpecifier,
  TypenameSpecifier,
}

union Statement {
  LabeledStatement,
  CaseStatement,
  DefaultStatement,
  ExpressionStatement,
  CompoundStatement,
  IfStatement,
  ConstevalIfStatement,
  SwitchStatement,
  WhileStatement,
  DoStatement,
  ForRangeStatement,
  ForStatement,
  BreakStatement,
  ContinueStatement,
  ReturnStatement,
  CoroutineReturnStatement,
  GotoStatement,
  DeclarationStatement,
  TryBlockStatement,
}

union TemplateArgument {
  TypeTemplateArgument,
  ExpressionTemplateArgument,
}

union TemplateParameter {
  TemplateTypeParameter,
  TemplatePackTypeParameter,
  NonTypeTemplateParameter,
  TypenameTypeParameter,
  ConstraintTypeParameter,
}

union Unit {
  TranslationUnit,
  ModuleUnit,
}

union UnqualifiedId {
  NameId,
  DestructorId,
  DecltypeId,
  OperatorFunctionId,
  LiteralOperatorId,
  ConversionFunctionId,
  SimpleTemplateId,
  LiteralOperatorTemplateId,
  OperatorFunctionTemplateId,
}

table GlobalModuleFragment /* AST */ {
  declaration_list: [Declaration];
  module_loc: SourceLocation;
  semicolon_loc: SourceLocation;
}

table PrivateModuleFragment /* AST */ {
  declaration_list: [Declaration];
  module_loc: SourceLocation;
  colon_loc: SourceLocation;
  private_loc: SourceLocation;
  semicolon_loc: SourceLocation;
}

table ModuleDeclaration /* AST */ {
  module_name: ModuleName;
  module_partition: ModulePartition;
  attribute_list: [AttributeSpecifier];
  export_loc: SourceLocation;
  module_loc: SourceLocation;
  semicolon_loc: SourceLocation;
}

table ModuleName /* AST */ {
  module_qualifier: ModuleQualifier;
  identifier: string;
  identifier_loc: SourceLocation;
}

table ModuleQualifier /* AST */ {
  module_qualifier: ModuleQualifier;
  identifier: string;
  identifier_loc: SourceLocation;
  dot_loc: SourceLocation;
}

table ModulePartition /* AST */ {
  module_name: ModuleName;
  colon_loc: SourceLocation;
}

table ImportName /* AST */ {
  module_partition: ModulePartition;
  module_name: ModuleName;
  header_loc: SourceLocation;
}

table InitDeclarator /* AST */ {
  declarator: Declarator;
  requires_clause: RequiresClause;
  initializer: Expression;
}

table Declarator /* AST */ {
  ptr_op_list: [PtrOperator];
  core_declarator: CoreDeclarator;
  declarator_chunk_list: [DeclaratorChunk];
}

table UsingDeclarator /* AST */ {
  nested_name_specifier: NestedNameSpecifier;
  unqualified_id: UnqualifiedId;
  typename_loc: SourceLocation;
  ellipsis_loc: SourceLocation;
}

table Enumerator /* AST */ {
  attribute_list: [AttributeSpecifier];
  expression: Expression;
  identifier: string;
  identifier_loc: SourceLocation;
  equal_loc: SourceLocation;
}

table TypeId /* AST */ {
  type_specifier_list: [Specifier];
  declarator: Declarator;
}

table Handler /* AST */ {
  exception_declaration: ExceptionDeclaration;
  statement: CompoundStatement;
  catch_loc: SourceLocation;
  lparen_loc: SourceLocation;
  rparen_loc: SourceLocation;
}

table BaseSpecifier /* AST */ {
  attribute_list: [AttributeSpecifier];
  nested_name_specifier: NestedNameSpecifier;
  unqualified_id: UnqualifiedId;
  access_specifier: uint32;
  template_loc: SourceLocation;
}

table RequiresClause /* AST */ {
  expression: Expression;
  requires_loc: SourceLocation;
}

table ParameterDeclarationClause /* AST */ {
  parameter_declaration_list: [ParameterDeclaration];
  comma_loc: SourceLocation;
  ellipsis_loc: SourceLocation;
}

table TrailingReturnType /* AST */ {
  type_id: TypeId;
  minus_greater_loc: SourceLocation;
}

table LambdaSpecifier /* AST */ {
  specifier: uint32;
  specifier_loc: SourceLocation;
}

table TypeConstraint /* AST */ {
  nested_name_specifier: NestedNameSpecifier;
  template_argument_list: [TemplateArgument];
  identifier: string;
  identifier_loc: SourceLocation;
  less_loc: SourceLocation;
  greater_loc: SourceLocation;
}

table AttributeArgumentClause /* AST */ {
  lparen_loc: SourceLocation;
  rparen_loc: SourceLocation;
}

table Attribute /* AST */ {
  attribute_token: AttributeToken;
  attribute_argument_clause: AttributeArgumentClause;
  ellipsis_loc: SourceLocation;
}

table AttributeUsingPrefix /* AST */ {
  using_loc: SourceLocation;
  attribute_namespace_loc: SourceLocation;
  colon_loc: SourceLocation;
}

table NewPlacement /* AST */ {
  expression_list: [Expression];
  lparen_loc: SourceLocation;
  rparen_loc: SourceLocation;
}

table NestedNamespaceSpecifier /* AST */ {
  identifier: string;
  inline_loc: SourceLocation;
  identifier_loc: SourceLocation;
  scope_loc: SourceLocation;
}

table CxxAttribute /* AttributeSpecifierAST */ {
  attribute_using_prefix: AttributeUsingPrefix;
  attribute_list: [Attribute];
  lbracket_loc: SourceLocation;
  lbracket2_loc: SourceLocation;
  rbracket_loc: SourceLocation;
  rbracket2_loc: SourceLocation;
}

table GccAttribute /* AttributeSpecifierAST */ {
  attribute_loc: SourceLocation;
  lparen_loc: SourceLocation;
  lparen2_loc: SourceLocation;
  rparen_loc: SourceLocation;
  rparen2_loc: SourceLocation;
}

table AlignasAttribute /* AttributeSpecifierAST */ {
  expression: Expression;
  alignas_loc: SourceLocation;
  lparen_loc: SourceLocation;
  ellipsis_loc: SourceLocation;
  rparen_loc: SourceLocation;
}

table AsmAttribute /* AttributeSpecifierAST */ {
  asm_loc: SourceLocation;
  lparen_loc: SourceLocation;
  literal_loc: SourceLocation;
  rparen_loc: SourceLocation;
}

table ScopedAttributeToken /* AttributeTokenAST */ {
  attribute_namespace: string;
  identifier: string;
  attribute_namespace_loc: SourceLocation;
  scope_loc: SourceLocation;
  identifier_loc: SourceLocation;
}

table SimpleAttributeToken /* AttributeTokenAST */ {
  identifier: string;
  identifier_loc: SourceLocation;
}

table BitfieldDeclarator /* CoreDeclaratorAST */ {
  size_expression: Expression;
  identifier: string;
  identifier_loc: SourceLocation;
  colon_loc: SourceLocation;
}

table ParameterPack /* CoreDeclaratorAST */ {
  core_declarator: CoreDeclarator;
  ellipsis_loc: SourceLocation;
}

table IdDeclarator /* CoreDeclaratorAST */ {
  declarator_id: IdExpression;
  attribute_list: [AttributeSpecifier];
}

table NestedDeclarator /* CoreDeclaratorAST */ {
  declarator: Declarator;
  lparen_loc: SourceLocation;
  rparen_loc: SourceLocation;
}

table SimpleDeclaration /* DeclarationAST */ {
  attribute_list: [AttributeSpecifier];
  decl_specifier_list: [Specifier];
  init_declarator_list: [InitDeclarator];
  requires_clause: RequiresClause;
  semicolon_loc: SourceLocation;
}

table AsmDeclaration /* DeclarationAST */ {
  attribute_list: [AttributeSpecifier];
  asm_qualifier_list: [AsmQualifier];
  output_operand_list: [AsmOperand];
  input_operand_list: [AsmOperand];
  clobber_list: [AsmClobber];
  goto_label_list: [AsmGotoLabel];
  asm_loc: SourceLocation;
  lparen_loc: SourceLocation;
  literal_loc: SourceLocation;
  rparen_loc: SourceLocation;
  semicolon_loc: SourceLocation;
}

table NamespaceAliasDefinition /* DeclarationAST */ {
  nested_name_specifier: NestedNameSpecifier;
  unqualified_id: NameId;
  identifier: string;
  namespace_loc: SourceLocation;
  identifier_loc: SourceLocation;
  equal_loc: SourceLocation;
  semicolon_loc: SourceLocation;
}

table UsingDeclaration /* DeclarationAST */ {
  using_declarator_list: [UsingDeclarator];
  using_loc: SourceLocation;
  semicolon_loc: SourceLocation;
}

table UsingEnumDeclaration /* DeclarationAST */ {
  enum_type_specifier: ElaboratedTypeSpecifier;
  using_loc: SourceLocation;
  semicolon_loc: SourceLocation;
}

table UsingDirective /* DeclarationAST */ {
  attribute_list: [AttributeSpecifier];
  nested_name_specifier: NestedNameSpecifier;
  unqualified_id: NameId;
  using_loc: SourceLocation;
  namespace_loc: SourceLocation;
  semicolon_loc: SourceLocation;
}

table StaticAssertDeclaration /* DeclarationAST */ {
  expression: Expression;
  static_assert_loc: SourceLocation;
  lparen_loc: SourceLocation;
  comma_loc: SourceLocation;
  literal_loc: SourceLocation;
  rparen_loc: SourceLocation;
  semicolon_loc: SourceLocation;
}

table AliasDeclaration /* DeclarationAST */ {
  attribute_list: [AttributeSpecifier];
  type_id: TypeId;
  identifier: string;
  using_loc: SourceLocation;
  identifier_loc: SourceLocation;
  equal_loc: SourceLocation;
  semicolon_loc: SourceLocation;
}

table OpaqueEnumDeclaration /* DeclarationAST */ {
  attribute_list: [AttributeSpecifier];
  nested_name_specifier: NestedNameSpecifier;
  unqualified_id: NameId;
  type_specifier_list: [Specifier];
  enum_loc: SourceLocation;
  class_loc: SourceLocation;
  colon_loc: SourceLocation;
  emicolon_loc: SourceLocation;
}

table FunctionDefinition /* DeclarationAST */ {
  attribute_list: [AttributeSpecifier];
  decl_specifier_list: [Specifier];
  declarator: Declarator;
  requires_clause: RequiresClause;
  function_body: FunctionBody;
}

table TemplateDeclaration /* DeclarationAST */ {
  template_parameter_list: [TemplateParameter];
  requires_clause: RequiresClause;
  declaration: Declaration;
  template_loc: SourceLocation;
  less_loc: SourceLocation;
  greater_loc: SourceLocation;
}

table ConceptDefinition /* DeclarationAST */ {
  expression: Expression;
  identifier: string;
  concept_loc: SourceLocation;
  identifier_loc: SourceLocation;
  equal_loc: SourceLocation;
  semicolon_loc: SourceLocation;
}

table DeductionGuide /* DeclarationAST */ {
  explicit_specifier: Specifier;
  parameter_declaration_clause: ParameterDeclarationClause;
  template_id: SimpleTemplateId;
  identifier: string;
  identifier_loc: SourceLocation;
  lparen_loc: SourceLocation;
  rparen_loc: SourceLocation;
  arrow_loc: SourceLocation;
  semicolon_loc: SourceLocation;
}

table ExplicitInstantiation /* DeclarationAST */ {
  declaration: Declaration;
  extern_loc: SourceLocation;
  template_loc: SourceLocation;
}

table ExportDeclaration /* DeclarationAST */ {
  declaration: Declaration;
  export_loc: SourceLocation;
}

table ExportCompoundDeclaration /* DeclarationAST */ {
  declaration_list: [Declaration];
  export_loc: SourceLocation;
  lbrace_loc: SourceLocation;
  rbrace_loc: SourceLocation;
}

table LinkageSpecification /* DeclarationAST */ {
  declaration_list: [Declaration];
  string_literal: string;
  extern_loc: SourceLocation;
  stringliteral_loc: SourceLocation;
  lbrace_loc: SourceLocation;
  rbrace_loc: SourceLocation;
}

table NamespaceDefinition /* DeclarationAST */ {
  attribute_list: [AttributeSpecifier];
  nested_namespace_specifier_list: [NestedNamespaceSpecifier];
  extra_attribute_list: [AttributeSpecifier];
  declaration_list: [Declaration];
  identifier: string;
  inline_loc: SourceLocation;
  namespace_loc: SourceLocation;
  identifier_loc: SourceLocation;
  lbrace_loc: SourceLocation;
  rbrace_loc: SourceLocation;
}

table EmptyDeclaration /* DeclarationAST */ {
  semicolon_loc: SourceLocation;
}

table AttributeDeclaration /* DeclarationAST */ {
  attribute_list: [AttributeSpecifier];
  semicolon_loc: SourceLocation;
}

table ModuleImportDeclaration /* DeclarationAST */ {
  import_name: ImportName;
  attribute_list: [AttributeSpecifier];
  import_loc: SourceLocation;
  semicolon_loc: SourceLocation;
}

table ParameterDeclaration /* DeclarationAST */ {
  attribute_list: [AttributeSpecifier];
  type_specifier_list: [Specifier];
  declarator: Declarator;
  expression: Expression;
  this_loc: SourceLocation;
  equal_loc: SourceLocation;
}

table AccessDeclaration /* DeclarationAST */ {
  access_specifier: uint32;
  access_loc: SourceLocation;
  colon_loc: SourceLocation;
}

table ForRangeDeclaration /* DeclarationAST */ {
}

table StructuredBindingDeclaration /* DeclarationAST */ {
  attribute_list: [AttributeSpecifier];
  decl_specifier_list: [Specifier];
  binding_list: [NameId];
  initializer: Expression;
  ref_qualifier_loc: SourceLocation;
  lbracket_loc: SourceLocation;
  rbracket_loc: SourceLocation;
  semicolon_loc: SourceLocation;
}

table AsmOperand /* DeclarationAST */ {
  expression: Expression;
  symbolic_name: string;
  lbracket_loc: SourceLocation;
  symbolic_name_loc: SourceLocation;
  rbracket_loc: SourceLocation;
  constraint_literal_loc: SourceLocation;
  lparen_loc: SourceLocation;
  rparen_loc: SourceLocation;
}

table AsmQualifier /* DeclarationAST */ {
  qualifier: uint32;
  qualifier_loc: SourceLocation;
}

table AsmClobber /* DeclarationAST */ {
  literal: string;
  literal_loc: SourceLocation;
}

table AsmGotoLabel /* DeclarationAST */ {
  identifier: string;
  identifier_loc: SourceLocation;
}

table FunctionDeclaratorChunk /* DeclaratorChunkAST */ {
  parameter_declaration_clause: ParameterDeclarationClause;
  cv_qualifier_list: [Specifier];
  exception_specifier: ExceptionSpecifier;
  attribute_list: [AttributeSpecifier];
  trailing_return_type: TrailingReturnType;
  lparen_loc: SourceLocation;
  rparen_loc: SourceLocation;
  ref_loc: SourceLocation;
}

table ArrayDeclaratorChunk /* DeclaratorChunkAST */ {
  expression: Expression;
  attribute_list: [AttributeSpecifier];
  lbracket_loc: SourceLocation;
  rbracket_loc: SourceLocation;
}

table EllipsisExceptionDeclaration /* ExceptionDeclarationAST */ {
  ellipsis_loc: SourceLocation;
}

table TypeExceptionDeclaration /* ExceptionDeclarationAST */ {
  attribute_list: [AttributeSpecifier];
  type_specifier_list: [Specifier];
  declarator: Declarator;
}

table ThrowExceptionSpecifier /* ExceptionSpecifierAST */ {
  throw_loc: SourceLocation;
  lparen_loc: SourceLocation;
  rparen_loc: SourceLocation;
}

table NoexceptSpecifier /* ExceptionSpecifierAST */ {
  expression: Expression;
  noexcept_loc: SourceLocation;
  lparen_loc: SourceLocation;
  rparen_loc: SourceLocation;
}

table CharLiteralExpression /* ExpressionAST */ {
  literal: string;
  literal_loc: SourceLocation;
}

table BoolLiteralExpression /* ExpressionAST */ {
  literal_loc: SourceLocation;
}

table IntLiteralExpression /* ExpressionAST */ {
  literal: string;
  literal_loc: SourceLocation;
}

table FloatLiteralExpression /* ExpressionAST */ {
  literal: string;
  literal_loc: SourceLocation;
}

table NullptrLiteralExpression /* ExpressionAST */ {
  literal: uint32;
  literal_loc: SourceLocation;
}

table StringLiteralExpression /* ExpressionAST */ {
  literal_loc: SourceLocation;
}

table UserDefinedStringLiteralExpression /* ExpressionAST */ {
  literal: string;
  literal_loc: SourceLocation;
}

table ThisExpression /* ExpressionAST */ {
  this_loc: SourceLocation;
}

table NestedExpression /* ExpressionAST */ {
  expression: Expression;
  lparen_loc: SourceLocation;
  rparen_loc: SourceLocation;
}

table IdExpression /* ExpressionAST */ {
  nested_name_specifier: NestedNameSpecifier;
  unqualified_id: UnqualifiedId;
  template_loc: SourceLocation;
}

table LambdaExpression /* ExpressionAST */ {
  capture_list: [LambdaCapture];
  template_parameter_list: [TemplateParameter];
  template_requires_clause: RequiresClause;
  parameter_declaration_clause: ParameterDeclarationClause;
  lambda_specifier_list: [LambdaSpecifier];
  exception_specifier: ExceptionSpecifier;
  attribute_list: [AttributeSpecifier];
  trailing_return_type: TrailingReturnType;
  requires_clause: RequiresClause;
  statement: CompoundStatement;
  lbracket_loc: SourceLocation;
  capture_default_loc: SourceLocation;
  rbracket_loc: SourceLocation;
  less_loc: SourceLocation;
  greater_loc: SourceLocation;
  lparen_loc: SourceLocation;
  rparen_loc: SourceLocation;
}

table FoldExpression /* ExpressionAST */ {
  left_expression: Expression;
  right_expression: Expression;
  op: uint32;
  fold_op: uint32;
  lparen_loc: SourceLocation;
  op_loc: SourceLocation;
  ellipsis_loc: SourceLocation;
  fold_op_loc: SourceLocation;
  rparen_loc: SourceLocation;
}

table RightFoldExpression /* ExpressionAST */ {
  expression: Expression;
  op: uint32;
  lparen_loc: SourceLocation;
  op_loc: SourceLocation;
  ellipsis_loc: SourceLocation;
  rparen_loc: SourceLocation;
}

table LeftFoldExpression /* ExpressionAST */ {
  expression: Expression;
  op: uint32;
  lparen_loc: SourceLocation;
  ellipsis_loc: SourceLocation;
  op_loc: SourceLocation;
  rparen_loc: SourceLocation;
}

table RequiresExpression /* ExpressionAST */ {
  parameter_declaration_clause: ParameterDeclarationClause;
  requirement_list: [Requirement];
  requires_loc: SourceLocation;
  lparen_loc: SourceLocation;
  rparen_loc: SourceLocation;
  lbrace_loc: SourceLocation;
  rbrace_loc: SourceLocation;
}

table SubscriptExpression /* ExpressionAST */ {
  base_expression: Expression;
  index_expression: Expression;
  lbracket_loc: SourceLocation;
  rbracket_loc: SourceLocation;
}

table CallExpression /* ExpressionAST */ {
  base_expression: Expression;
  expression_list: [Expression];
  lparen_loc: SourceLocation;
  rparen_loc: SourceLocation;
}

table TypeConstruction /* ExpressionAST */ {
  type_specifier: Specifier;
  expression_list: [Expression];
  lparen_loc: SourceLocation;
  rparen_loc: SourceLocation;
}

table BracedTypeConstruction /* ExpressionAST */ {
  type_specifier: Specifier;
  braced_init_list: BracedInitList;
}

table MemberExpression /* ExpressionAST */ {
  base_expression: Expression;
  member_id: IdExpression;
  access_op: uint32;
  access_loc: SourceLocation;
}

table PostIncrExpression /* ExpressionAST */ {
  base_expression: Expression;
  op: uint32;
  op_loc: SourceLocation;
}

table CppCastExpression /* ExpressionAST */ {
  type_id: TypeId;
  expression: Expression;
  cast_loc: SourceLocation;
  less_loc: SourceLocation;
  greater_loc: SourceLocation;
  lparen_loc: SourceLocation;
  rparen_loc: SourceLocation;
}

table TypeidExpression /* ExpressionAST */ {
  expression: Expression;
  typeid_loc: SourceLocation;
  lparen_loc: SourceLocation;
  rparen_loc: SourceLocation;
}

table TypeidOfTypeExpression /* ExpressionAST */ {
  type_id: TypeId;
  typeid_loc: SourceLocation;
  lparen_loc: SourceLocation;
  rparen_loc: SourceLocation;
}

table UnaryExpression /* ExpressionAST */ {
  expression: Expression;
  op: uint32;
  op_loc: SourceLocation;
}

table AwaitExpression /* ExpressionAST */ {
  expression: Expression;
  await_loc: SourceLocation;
}

table SizeofExpression /* ExpressionAST */ {
  expression: Expression;
  sizeof_loc: SourceLocation;
}

table SizeofTypeExpression /* ExpressionAST */ {
  type_id: TypeId;
  sizeof_loc: SourceLocation;
  lparen_loc: SourceLocation;
  rparen_loc: SourceLocation;
}

table SizeofPackExpression /* ExpressionAST */ {
  identifier: string;
  sizeof_loc: SourceLocation;
  ellipsis_loc: SourceLocation;
  lparen_loc: SourceLocation;
  identifier_loc: SourceLocation;
  rparen_loc: SourceLocation;
}

table AlignofTypeExpression /* ExpressionAST */ {
  type_id: TypeId;
  alignof_loc: SourceLocation;
  lparen_loc: SourceLocation;
  rparen_loc: SourceLocation;
}

table AlignofExpression /* ExpressionAST */ {
  expression: Expression;
  alignof_loc: SourceLocation;
}

table NoexceptExpression /* ExpressionAST */ {
  expression: Expression;
  noexcept_loc: SourceLocation;
  lparen_loc: SourceLocation;
  rparen_loc: SourceLocation;
}

table NewExpression /* ExpressionAST */ {
  new_placement: NewPlacement;
  type_specifier_list: [Specifier];
  declarator: Declarator;
  new_initalizer: NewInitializer;
  scope_loc: SourceLocation;
  new_loc: SourceLocation;
  lparen_loc: SourceLocation;
  rparen_loc: SourceLocation;
}

table DeleteExpression /* ExpressionAST */ {
  expression: Expression;
  scope_loc: SourceLocation;
  delete_loc: SourceLocation;
  lbracket_loc: SourceLocation;
  rbracket_loc: SourceLocation;
}

table CastExpression /* ExpressionAST */ {
  type_id: TypeId;
  expression: Expression;
  lparen_loc: SourceLocation;
  rparen_loc: SourceLocation;
}

table ImplicitCastExpression /* ExpressionAST */ {
  expression: Expression;
}

table BinaryExpression /* ExpressionAST */ {
  left_expression: Expression;
  right_expression: Expression;
  op: uint32;
  op_loc: SourceLocation;
}

table ConditionalExpression /* ExpressionAST */ {
  condition: Expression;
  iftrue_expression: Expression;
  iffalse_expression: Expression;
  question_loc: SourceLocation;
  colon_loc: SourceLocation;
}

table YieldExpression /* ExpressionAST */ {
  expression: Expression;
  yield_loc: SourceLocation;
}

table ThrowExpression /* ExpressionAST */ {
  expression: Expression;
  throw_loc: SourceLocation;
}

table AssignmentExpression /* ExpressionAST */ {
  left_expression: Expression;
  right_expression: Expression;
  op: uint32;
  op_loc: SourceLocation;
}

table PackExpansionExpression /* ExpressionAST */ {
  expression: Expression;
  ellipsis_loc: SourceLocation;
}

table DesignatedInitializerClause /* ExpressionAST */ {
  identifier: string;
  initializer: Expression;
  dot_loc: SourceLocation;
  identifier_loc: SourceLocation;
}

table TypeTraitsExpression /* ExpressionAST */ {
  type_id_list: [TypeId];
  type_traits: uint32;
  type_traits_loc: SourceLocation;
  lparen_loc: SourceLocation;
  rparen_loc: SourceLocation;
}

table ConditionExpression /* ExpressionAST */ {
  attribute_list: [AttributeSpecifier];
  decl_specifier_list: [Specifier];
  declarator: Declarator;
  initializer: Expression;
}

table EqualInitializer /* ExpressionAST */ {
  expression: Expression;
  equal_loc: SourceLocation;
}

table BracedInitList /* ExpressionAST */ {
  expression_list: [Expression];
  lbrace_loc: SourceLocation;
  comma_loc: SourceLocation;
  rbrace_loc: SourceLocation;
}

table ParenInitializer /* ExpressionAST */ {
  expression_list: [Expression];
  lparen_loc: SourceLocation;
  rparen_loc: SourceLocation;
}

table DefaultFunctionBody /* FunctionBodyAST */ {
  equal_loc: SourceLocation;
  default_loc: SourceLocation;
  semicolon_loc: SourceLocation;
}

table CompoundStatementFunctionBody /* FunctionBodyAST */ {
  mem_initializer_list: [MemInitializer];
  statement: CompoundStatement;
  colon_loc: SourceLocation;
}

table TryStatementFunctionBody /* FunctionBodyAST */ {
  mem_initializer_list: [MemInitializer];
  statement: CompoundStatement;
  handler_list: [Handler];
  try_loc: SourceLocation;
  colon_loc: SourceLocation;
}

table DeleteFunctionBody /* FunctionBodyAST */ {
  equal_loc: SourceLocation;
  delete_loc: SourceLocation;
  semicolon_loc: SourceLocation;
}

table ThisLambdaCapture /* LambdaCaptureAST */ {
  this_loc: SourceLocation;
}

table DerefThisLambdaCapture /* LambdaCaptureAST */ {
  star_loc: SourceLocation;
  this_loc: SourceLocation;
}

table SimpleLambdaCapture /* LambdaCaptureAST */ {
  identifier: string;
  identifier_loc: SourceLocation;
  ellipsis_loc: SourceLocation;
}

table RefLambdaCapture /* LambdaCaptureAST */ {
  identifier: string;
  amp_loc: SourceLocation;
  identifier_loc: SourceLocation;
  ellipsis_loc: SourceLocation;
}

table RefInitLambdaCapture /* LambdaCaptureAST */ {
  initializer: Expression;
  identifier: string;
  amp_loc: SourceLocation;
  ellipsis_loc: SourceLocation;
  identifier_loc: SourceLocation;
}

table InitLambdaCapture /* LambdaCaptureAST */ {
  initializer: Expression;
  identifier: string;
  ellipsis_loc: SourceLocation;
  identifier_loc: SourceLocation;
}

table ParenMemInitializer /* MemInitializerAST */ {
  nested_name_specifier: NestedNameSpecifier;
  unqualified_id: UnqualifiedId;
  expression_list: [Expression];
  lparen_loc: SourceLocation;
  rparen_loc: SourceLocation;
  ellipsis_loc: SourceLocation;
}

table BracedMemInitializer /* MemInitializerAST */ {
  nested_name_specifier: NestedNameSpecifier;
  unqualified_id: UnqualifiedId;
  braced_init_list: BracedInitList;
  ellipsis_loc: SourceLocation;
}

table GlobalNestedNameSpecifier /* NestedNameSpecifierAST */ {
  scope_loc: SourceLocation;
}

table SimpleNestedNameSpecifier /* NestedNameSpecifierAST */ {
  nested_name_specifier: NestedNameSpecifier;
  identifier: string;
  identifier_loc: SourceLocation;
  scope_loc: SourceLocation;
}

table DecltypeNestedNameSpecifier /* NestedNameSpecifierAST */ {
  nested_name_specifier: NestedNameSpecifier;
  decltype_specifier: DecltypeSpecifier;
  scope_loc: SourceLocation;
}

table TemplateNestedNameSpecifier /* NestedNameSpecifierAST */ {
  nested_name_specifier: NestedNameSpecifier;
  template_id: SimpleTemplateId;
  template_loc: SourceLocation;
  scope_loc: SourceLocation;
}

table NewParenInitializer /* NewInitializerAST */ {
  expression_list: [Expression];
  lparen_loc: SourceLocation;
  rparen_loc: SourceLocation;
}

table NewBracedInitializer /* NewInitializerAST */ {
  braced_init_list: BracedInitList;
}

table PointerOperator /* PtrOperatorAST */ {
  attribute_list: [AttributeSpecifier];
  cv_qualifier_list: [Specifier];
  star_loc: SourceLocation;
}

table ReferenceOperator /* PtrOperatorAST */ {
  attribute_list: [AttributeSpecifier];
  ref_op: uint32;
  ref_loc: SourceLocation;
}

table PtrToMemberOperator /* PtrOperatorAST */ {
  nested_name_specifier: NestedNameSpecifier;
  attribute_list: [AttributeSpecifier];
  cv_qualifier_list: [Specifier];
  star_loc: SourceLocation;
}

table SimpleRequirement /* RequirementAST */ {
  expression: Expression;
  semicolon_loc: SourceLocation;
}

table CompoundRequirement /* RequirementAST */ {
  expression: Expression;
  type_constraint: TypeConstraint;
  lbrace_loc: SourceLocation;
  rbrace_loc: SourceLocation;
  noexcept_loc: SourceLocation;
  minus_greater_loc: SourceLocation;
  semicolon_loc: SourceLocation;
}

table TypeRequirement /* RequirementAST */ {
  nested_name_specifier: NestedNameSpecifier;
  unqualified_id: UnqualifiedId;
  typename_loc: SourceLocation;
  semicolon_loc: SourceLocation;
}

table NestedRequirement /* RequirementAST */ {
  expression: Expression;
  requires_loc: SourceLocation;
  semicolon_loc: SourceLocation;
}

table TypedefSpecifier /* SpecifierAST */ {
  typedef_loc: SourceLocation;
}

table FriendSpecifier /* SpecifierAST */ {
  friend_loc: SourceLocation;
}

table ConstevalSpecifier /* SpecifierAST */ {
  consteval_loc: SourceLocation;
}

table ConstinitSpecifier /* SpecifierAST */ {
  constinit_loc: SourceLocation;
}

table ConstexprSpecifier /* SpecifierAST */ {
  constexpr_loc: SourceLocation;
}

table InlineSpecifier /* SpecifierAST */ {
  inline_loc: SourceLocation;
}

table StaticSpecifier /* SpecifierAST */ {
  static_loc: SourceLocation;
}

table ExternSpecifier /* SpecifierAST */ {
  extern_loc: SourceLocation;
}

table ThreadLocalSpecifier /* SpecifierAST */ {
  thread_local_loc: SourceLocation;
}

table ThreadSpecifier /* SpecifierAST */ {
  thread_loc: SourceLocation;
}

table MutableSpecifier /* SpecifierAST */ {
  mutable_loc: SourceLocation;
}

table VirtualSpecifier /* SpecifierAST */ {
  virtual_loc: SourceLocation;
}

table ExplicitSpecifier /* SpecifierAST */ {
  expression: Expression;
  explicit_loc: SourceLocation;
  lparen_loc: SourceLocation;
  rparen_loc: SourceLocation;
}

table AutoTypeSpecifier /* SpecifierAST */ {
  auto_loc: SourceLocation;
}

table VoidTypeSpecifier /* SpecifierAST */ {
  void_loc: SourceLocation;
}

table SizeTypeSpecifier /* SpecifierAST */ {
  specifier: uint32;
  specifier_loc: SourceLocation;
}

table SignTypeSpecifier /* SpecifierAST */ {
  specifier: uint32;
  specifier_loc: SourceLocation;
}

table VaListTypeSpecifier /* SpecifierAST */ {
  specifier: uint32;
  specifier_loc: SourceLocation;
}

table IntegralTypeSpecifier /* SpecifierAST */ {
  specifier: uint32;
  specifier_loc: SourceLocation;
}

table FloatingPointTypeSpecifier /* SpecifierAST */ {
  specifier: uint32;
  specifier_loc: SourceLocation;
}

table ComplexTypeSpecifier /* SpecifierAST */ {
  complex_loc: SourceLocation;
}

table NamedTypeSpecifier /* SpecifierAST */ {
  nested_name_specifier: NestedNameSpecifier;
  unqualified_id: UnqualifiedId;
  template_loc: SourceLocation;
}

table AtomicTypeSpecifier /* SpecifierAST */ {
  type_id: TypeId;
  atomic_loc: SourceLocation;
  lparen_loc: SourceLocation;
  rparen_loc: SourceLocation;
}

table UnderlyingTypeSpecifier /* SpecifierAST */ {
  type_id: TypeId;
  underlying_type_loc: SourceLocation;
  lparen_loc: SourceLocation;
  rparen_loc: SourceLocation;
}

table ElaboratedTypeSpecifier /* SpecifierAST */ {
  attribute_list: [AttributeSpecifier];
  nested_name_specifier: NestedNameSpecifier;
  unqualified_id: UnqualifiedId;
  class_key: uint32;
  class_loc: SourceLocation;
}

table DecltypeAutoSpecifier /* SpecifierAST */ {
  decltype_loc: SourceLocation;
  lparen_loc: SourceLocation;
  auto_loc: SourceLocation;
  rparen_loc: SourceLocation;
}

table DecltypeSpecifier /* SpecifierAST */ {
  expression: Expression;
  decltype_loc: SourceLocation;
  lparen_loc: SourceLocation;
  rparen_loc: SourceLocation;
}

table PlaceholderTypeSpecifier /* SpecifierAST */ {
  type_constraint: TypeConstraint;
  specifier: Specifier;
}

table ConstQualifier /* SpecifierAST */ {
  const_loc: SourceLocation;
}

table VolatileQualifier /* SpecifierAST */ {
  volatile_loc: SourceLocation;
}

table RestrictQualifier /* SpecifierAST */ {
  restrict_loc: SourceLocation;
}

table EnumSpecifier /* SpecifierAST */ {
  attribute_list: [AttributeSpecifier];
  nested_name_specifier: NestedNameSpecifier;
  unqualified_id: NameId;
  type_specifier_list: [Specifier];
  enumerator_list: [Enumerator];
  enum_loc: SourceLocation;
  class_loc: SourceLocation;
  colon_loc: SourceLocation;
  lbrace_loc: SourceLocation;
  comma_loc: SourceLocation;
  rbrace_loc: SourceLocation;
}

table ClassSpecifier /* SpecifierAST */ {
  attribute_list: [AttributeSpecifier];
  nested_name_specifier: NestedNameSpecifier;
  unqualified_id: UnqualifiedId;
  base_specifier_list: [BaseSpecifier];
  declaration_list: [Declaration];
  class_key: uint32;
  class_loc: SourceLocation;
  final_loc: SourceLocation;
  colon_loc: SourceLocation;
  lbrace_loc: SourceLocation;
  rbrace_loc: SourceLocation;
}

table TypenameSpecifier /* SpecifierAST */ {
  nested_name_specifier: NestedNameSpecifier;
  unqualified_id: UnqualifiedId;
  typename_loc: SourceLocation;
}

table LabeledStatement /* StatementAST */ {
  identifier: string;
  identifier_loc: SourceLocation;
  colon_loc: SourceLocation;
}

table CaseStatement /* StatementAST */ {
  expression: Expression;
  case_loc: SourceLocation;
  colon_loc: SourceLocation;
}

table DefaultStatement /* StatementAST */ {
  default_loc: SourceLocation;
  colon_loc: SourceLocation;
}

table ExpressionStatement /* StatementAST */ {
  expression: Expression;
  semicolon_loc: SourceLocation;
}

table CompoundStatement /* StatementAST */ {
  statement_list: [Statement];
  lbrace_loc: SourceLocation;
  rbrace_loc: SourceLocation;
}

table IfStatement /* StatementAST */ {
  initializer: Statement;
  condition: Expression;
  statement: Statement;
  else_statement: Statement;
  if_loc: SourceLocation;
  constexpr_loc: SourceLocation;
  lparen_loc: SourceLocation;
  rparen_loc: SourceLocation;
  else_loc: SourceLocation;
}

table ConstevalIfStatement /* StatementAST */ {
  statement: Statement;
  else_statement: Statement;
  if_loc: SourceLocation;
  exclaim_loc: SourceLocation;
  constval_loc: SourceLocation;
  else_loc: SourceLocation;
}

table SwitchStatement /* StatementAST */ {
  initializer: Statement;
  condition: Expression;
  statement: Statement;
  switch_loc: SourceLocation;
  lparen_loc: SourceLocation;
  rparen_loc: SourceLocation;
}

table WhileStatement /* StatementAST */ {
  condition: Expression;
  statement: Statement;
  while_loc: SourceLocation;
  lparen_loc: SourceLocation;
  rparen_loc: SourceLocation;
}

table DoStatement /* StatementAST */ {
  statement: Statement;
  expression: Expression;
  do_loc: SourceLocation;
  while_loc: SourceLocation;
  lparen_loc: SourceLocation;
  rparen_loc: SourceLocation;
  semicolon_loc: SourceLocation;
}

table ForRangeStatement /* StatementAST */ {
  initializer: Statement;
  range_declaration: Declaration;
  range_initializer: Expression;
  statement: Statement;
  for_loc: SourceLocation;
  lparen_loc: SourceLocation;
  colon_loc: SourceLocation;
  rparen_loc: SourceLocation;
}

table ForStatement /* StatementAST */ {
  initializer: Statement;
  condition: Expression;
  expression: Expression;
  statement: Statement;
  for_loc: SourceLocation;
  lparen_loc: SourceLocation;
  semicolon_loc: SourceLocation;
  rparen_loc: SourceLocation;
}

table BreakStatement /* StatementAST */ {
  break_loc: SourceLocation;
  semicolon_loc: SourceLocation;
}

table ContinueStatement /* StatementAST */ {
  continue_loc: SourceLocation;
  semicolon_loc: SourceLocation;
}

table ReturnStatement /* StatementAST */ {
  expression: Expression;
  return_loc: SourceLocation;
  semicolon_loc: SourceLocation;
}

table CoroutineReturnStatement /* StatementAST */ {
  expression: Expression;
  coreturn_loc: SourceLocation;
  semicolon_loc: SourceLocation;
}

table GotoStatement /* StatementAST */ {
  identifier: string;
  goto_loc: SourceLocation;
  identifier_loc: SourceLocation;
  semicolon_loc: SourceLocation;
}

table DeclarationStatement /* StatementAST */ {
  declaration: Declaration;
}

table TryBlockStatement /* StatementAST */ {
  statement: CompoundStatement;
  handler_list: [Handler];
  try_loc: SourceLocation;
}

table TypeTemplateArgument /* TemplateArgumentAST */ {
  type_id: TypeId;
}

table ExpressionTemplateArgument /* TemplateArgumentAST */ {
  expression: Expression;
}

table TemplateTypeParameter /* TemplateParameterAST */ {
  template_parameter_list: [TemplateParameter];
  requires_clause: RequiresClause;
  id_expression: IdExpression;
  identifier: string;
  template_loc: SourceLocation;
  less_loc: SourceLocation;
  greater_loc: SourceLocation;
  class_key_loc: SourceLocation;
  identifier_loc: SourceLocation;
  equal_loc: SourceLocation;
}

table TemplatePackTypeParameter /* TemplateParameterAST */ {
  template_parameter_list: [TemplateParameter];
  identifier: string;
  template_loc: SourceLocation;
  less_loc: SourceLocation;
  greater_loc: SourceLocation;
  class_key_loc: SourceLocation;
  ellipsis_loc: SourceLocation;
  identifier_loc: SourceLocation;
}

table NonTypeTemplateParameter /* TemplateParameterAST */ {
  declaration: ParameterDeclaration;
}

table TypenameTypeParameter /* TemplateParameterAST */ {
  type_id: TypeId;
  identifier: string;
  class_key_loc: SourceLocation;
  ellipsis_loc: SourceLocation;
  identifier_loc: SourceLocation;
  equal_loc: SourceLocation;
}

table ConstraintTypeParameter /* TemplateParameterAST */ {
  type_constraint: TypeConstraint;
  type_id: TypeId;
  identifier: string;
  ellipsis_loc: SourceLocation;
  identifier_loc: SourceLocation;
  equal_loc: SourceLocation;
}

table TranslationUnit /* UnitAST */ {
  declaration_list: [Declaration];
}

table ModuleUnit /* UnitAST */ {
  global_module_fragment: GlobalModuleFragment;
  module_declaration: ModuleDeclaration;
  declaration_list: [Declaration];
  private_module_fragment: PrivateModuleFragment;
}

table NameId /* UnqualifiedIdAST */ {
  identifier: string;
  identifier_loc: SourceLocation;
}

table DestructorId /* UnqualifiedIdAST */ {
  id: UnqualifiedId;
  tilde_loc: SourceLocation;
}

table DecltypeId /* UnqualifiedIdAST */ {
  decltype_specifier: DecltypeSpecifier;
}

table OperatorFunctionId /* UnqualifiedIdAST */ {
  op: uint32;
  operator_loc: SourceLocation;
  op_loc: SourceLocation;
  open_loc: SourceLocation;
  close_loc: SourceLocation;
}

table LiteralOperatorId /* UnqualifiedIdAST */ {
  identifier: string;
  operator_loc: SourceLocation;
  literal_loc: SourceLocation;
  identifier_loc: SourceLocation;
}

table ConversionFunctionId /* UnqualifiedIdAST */ {
  type_id: TypeId;
  operator_loc: SourceLocation;
}

table SimpleTemplateId /* UnqualifiedIdAST */ {
  template_argument_list: [TemplateArgument];
  identifier: string;
  identifier_loc: SourceLocation;
  less_loc: SourceLocation;
  greater_loc: SourceLocation;
}

table LiteralOperatorTemplateId /* UnqualifiedIdAST */ {
  literal_operator_id: LiteralOperatorId;
  template_argument_list: [TemplateArgument];
  less_loc: SourceLocation;
  greater_loc: SourceLocation;
}

table OperatorFunctionTemplateId /* UnqualifiedIdAST */ {
  operator_function_id: OperatorFunctionId;
  template_argument_list: [TemplateArgument];
  less_loc: SourceLocation;
  greater_loc: SourceLocation;
}


table SerializedUnit {
  version: uint32;
  unit: Unit;
  file_name: string;
}

root_type SerializedUnit;
file_identifier "AST0";
file_extension "ast";
