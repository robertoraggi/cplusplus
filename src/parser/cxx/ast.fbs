// Copyright (c) 2023 Roberto Raggi <roberto.raggi@gmail.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

namespace cxx.io;

table SourceLine {
  file_name: string;
  line: uint32;
}

table SourceLocation {
  source_line: SourceLine;
  column: uint32;
}

union AST {
  TypeId,
  NestedNameSpecifier,
  UsingDeclarator,
  Handler,
  EnumBase,
  Enumerator,
  Declarator,
  InitDeclarator,
  BaseSpecifier,
  BaseClause,
  NewTypeId,
  RequiresClause,
  ParameterDeclarationClause,
  ParametersAndQualifiers,
  LambdaIntroducer,
  LambdaDeclarator,
  TrailingReturnType,
  CtorInitializer,
  RequirementBody,
  TypeConstraint,
  GlobalModuleFragment,
  PrivateModuleFragment,
  ModuleDeclaration,
  ModuleName,
  ImportName,
  ModulePartition,
}

union Attribute {
}

union CoreDeclarator {
  IdDeclarator,
  NestedDeclarator,
}

union Declaration {
  AccessDeclaration,
  FunctionDefinition,
  ConceptDefinition,
  ForRangeDeclaration,
  AliasDeclaration,
  SimpleDeclaration,
  StaticAssertDeclaration,
  EmptyDeclaration,
  AttributeDeclaration,
  OpaqueEnumDeclaration,
  UsingEnumDeclaration,
  NamespaceDefinition,
  NamespaceAliasDefinition,
  UsingDirective,
  UsingDeclaration,
  AsmDeclaration,
  ExportDeclaration,
  ExportCompoundDeclaration,
  ModuleImportDeclaration,
  TemplateDeclaration,
  TypenameTypeParameter,
  TemplateTypeParameter,
  TemplatePackTypeParameter,
  DeductionGuide,
  ExplicitInstantiation,
  ParameterDeclaration,
  LinkageSpecification,
}

union DeclaratorModifier {
  FunctionDeclarator,
  ArrayDeclarator,
}

union ExceptionDeclaration {
  EllipsisExceptionDeclaration,
  TypeExceptionDeclaration,
}

union Expression {
  ThisExpression,
  CharLiteralExpression,
  BoolLiteralExpression,
  IntLiteralExpression,
  FloatLiteralExpression,
  NullptrLiteralExpression,
  StringLiteralExpression,
  UserDefinedStringLiteralExpression,
  IdExpression,
  RequiresExpression,
  NestedExpression,
  RightFoldExpression,
  LeftFoldExpression,
  FoldExpression,
  LambdaExpression,
  SizeofExpression,
  SizeofTypeExpression,
  SizeofPackExpression,
  TypeidExpression,
  TypeidOfTypeExpression,
  AlignofExpression,
  TypeTraitsExpression,
  UnaryExpression,
  BinaryExpression,
  AssignmentExpression,
  BracedTypeConstruction,
  TypeConstruction,
  CallExpression,
  SubscriptExpression,
  MemberExpression,
  PostIncrExpression,
  ConditionalExpression,
  ImplicitCastExpression,
  CastExpression,
  CppCastExpression,
  NewExpression,
  DeleteExpression,
  ThrowExpression,
  NoexceptExpression,
}

union FunctionBody {
  DefaultFunctionBody,
  CompoundStatementFunctionBody,
  TryStatementFunctionBody,
  DeleteFunctionBody,
}

union Initializer {
  EqualInitializer,
  BracedInitList,
  ParenInitializer,
}

union LambdaCapture {
  ThisLambdaCapture,
  DerefThisLambdaCapture,
  SimpleLambdaCapture,
  RefLambdaCapture,
  RefInitLambdaCapture,
  InitLambdaCapture,
}

union MemInitializer {
  ParenMemInitializer,
  BracedMemInitializer,
}

union Name {
  SimpleName,
  DestructorName,
  DecltypeName,
  OperatorName,
  ConversionName,
  TemplateName,
  QualifiedName,
}

union NewInitializer {
  NewParenInitializer,
  NewBracedInitializer,
}

union PtrOperator {
  PointerOperator,
  ReferenceOperator,
  PtrToMemberOperator,
}

union Requirement {
  SimpleRequirement,
  CompoundRequirement,
  TypeRequirement,
  NestedRequirement,
}

union Specifier {
  TypedefSpecifier,
  FriendSpecifier,
  ConstevalSpecifier,
  ConstinitSpecifier,
  ConstexprSpecifier,
  InlineSpecifier,
  StaticSpecifier,
  ExternSpecifier,
  ThreadLocalSpecifier,
  ThreadSpecifier,
  MutableSpecifier,
  VirtualSpecifier,
  ExplicitSpecifier,
  AutoTypeSpecifier,
  VoidTypeSpecifier,
  VaListTypeSpecifier,
  IntegralTypeSpecifier,
  FloatingPointTypeSpecifier,
  ComplexTypeSpecifier,
  NamedTypeSpecifier,
  AtomicTypeSpecifier,
  UnderlyingTypeSpecifier,
  ElaboratedTypeSpecifier,
  DecltypeAutoSpecifier,
  DecltypeSpecifier,
  PlaceholderTypeSpecifier,
  ConstQualifier,
  VolatileQualifier,
  RestrictQualifier,
  EnumSpecifier,
  ClassSpecifier,
  TypenameSpecifier,
}

union Statement {
  LabeledStatement,
  CaseStatement,
  DefaultStatement,
  ExpressionStatement,
  CompoundStatement,
  IfStatement,
  SwitchStatement,
  WhileStatement,
  DoStatement,
  ForRangeStatement,
  ForStatement,
  BreakStatement,
  ContinueStatement,
  ReturnStatement,
  GotoStatement,
  CoroutineReturnStatement,
  DeclarationStatement,
  TryBlockStatement,
}

union TemplateArgument {
  TypeTemplateArgument,
  ExpressionTemplateArgument,
}

union Unit {
  TranslationUnit,
  ModuleUnit,
}

table TypeId /* AST */ {
  type_specifier_list: [Specifier];
  declarator: Declarator;
}

table NestedNameSpecifier /* AST */ {
  name_list: [Name];
  scope_loc: SourceLocation;
}

table UsingDeclarator /* AST */ {
  nested_name_specifier: NestedNameSpecifier;
  name: Name;
  typename_loc: SourceLocation;
}

table Handler /* AST */ {
  exception_declaration: ExceptionDeclaration;
  statement: CompoundStatement;
  catch_loc: SourceLocation;
  lparen_loc: SourceLocation;
  rparen_loc: SourceLocation;
}

table EnumBase /* AST */ {
  type_specifier_list: [Specifier];
  colon_loc: SourceLocation;
}

table Enumerator /* AST */ {
  name: Name;
  attribute_list: [Attribute];
  expression: Expression;
  equal_loc: SourceLocation;
}

table Declarator /* AST */ {
  ptr_op_list: [PtrOperator];
  core_declarator: CoreDeclarator;
  modifiers: [DeclaratorModifier];
}

table InitDeclarator /* AST */ {
  declarator: Declarator;
  requires_clause: RequiresClause;
  initializer: Initializer;
}

table BaseSpecifier /* AST */ {
  attribute_list: [Attribute];
  name: Name;
}

table BaseClause /* AST */ {
  base_specifier_list: [BaseSpecifier];
  colon_loc: SourceLocation;
}

table NewTypeId /* AST */ {
  type_specifier_list: [Specifier];
}

table RequiresClause /* AST */ {
  expression: Expression;
  requires_loc: SourceLocation;
}

table ParameterDeclarationClause /* AST */ {
  parameter_declaration_list: [ParameterDeclaration];
  comma_loc: SourceLocation;
  ellipsis_loc: SourceLocation;
}

table ParametersAndQualifiers /* AST */ {
  parameter_declaration_clause: ParameterDeclarationClause;
  cv_qualifier_list: [Specifier];
  attribute_list: [Attribute];
  lparen_loc: SourceLocation;
  rparen_loc: SourceLocation;
  ref_loc: SourceLocation;
}

table LambdaIntroducer /* AST */ {
  capture_list: [LambdaCapture];
  lbracket_loc: SourceLocation;
  capture_default_loc: SourceLocation;
  rbracket_loc: SourceLocation;
}

table LambdaDeclarator /* AST */ {
  parameter_declaration_clause: ParameterDeclarationClause;
  decl_specifier_list: [Specifier];
  attribute_list: [Attribute];
  trailing_return_type: TrailingReturnType;
  requires_clause: RequiresClause;
  lparen_loc: SourceLocation;
  rparen_loc: SourceLocation;
}

table TrailingReturnType /* AST */ {
  type_id: TypeId;
  minus_greater_loc: SourceLocation;
}

table CtorInitializer /* AST */ {
  mem_initializer_list: [MemInitializer];
  colon_loc: SourceLocation;
}

table RequirementBody /* AST */ {
  requirement_list: [Requirement];
  lbrace_loc: SourceLocation;
  rbrace_loc: SourceLocation;
}

table TypeConstraint /* AST */ {
  nested_name_specifier: NestedNameSpecifier;
  name: Name;
}

table GlobalModuleFragment /* AST */ {
  declaration_list: [Declaration];
  module_loc: SourceLocation;
  semicolon_loc: SourceLocation;
}

table PrivateModuleFragment /* AST */ {
  declaration_list: [Declaration];
  module_loc: SourceLocation;
  colon_loc: SourceLocation;
  private_loc: SourceLocation;
  semicolon_loc: SourceLocation;
}

table ModuleDeclaration /* AST */ {
  module_name: ModuleName;
  module_partition: ModulePartition;
  attribute_list: [Attribute];
  export_loc: SourceLocation;
  module_loc: SourceLocation;
  semicolon_loc: SourceLocation;
}

table ModuleName /* AST */ {
  identifier_list: [SourceLocation];
}

table ImportName /* AST */ {
  module_partition: ModulePartition;
  module_name: ModuleName;
  header_loc: SourceLocation;
}

table ModulePartition /* AST */ {
  module_name: ModuleName;
  colon_loc: SourceLocation;
}

table IdDeclarator /* CoreDeclaratorAST */ {
  name: Name;
  attribute_list: [Attribute];
  ellipsis_loc: SourceLocation;
}

table NestedDeclarator /* CoreDeclaratorAST */ {
  declarator: Declarator;
  lparen_loc: SourceLocation;
  rparen_loc: SourceLocation;
}

table AccessDeclaration /* DeclarationAST */ {
  access_loc: SourceLocation;
  colon_loc: SourceLocation;
}

table FunctionDefinition /* DeclarationAST */ {
  attribute_list: [Attribute];
  decl_specifier_list: [Specifier];
  declarator: Declarator;
  requires_clause: RequiresClause;
  function_body: FunctionBody;
}

table ConceptDefinition /* DeclarationAST */ {
  name: Name;
  expression: Expression;
  concept_loc: SourceLocation;
  equal_loc: SourceLocation;
  semicolon_loc: SourceLocation;
}

table ForRangeDeclaration /* DeclarationAST */ {
}

table AliasDeclaration /* DeclarationAST */ {
  attribute_list: [Attribute];
  type_id: TypeId;
  identifier: string;
  using_loc: SourceLocation;
  identifier_loc: SourceLocation;
  equal_loc: SourceLocation;
  semicolon_loc: SourceLocation;
}

table SimpleDeclaration /* DeclarationAST */ {
  attribute_list: [Attribute];
  decl_specifier_list: [Specifier];
  init_declarator_list: [InitDeclarator];
  requires_clause: RequiresClause;
  semicolon_loc: SourceLocation;
}

table StaticAssertDeclaration /* DeclarationAST */ {
  expression: Expression;
  static_assert_loc: SourceLocation;
  lparen_loc: SourceLocation;
  comma_loc: SourceLocation;
  string_literal_list: [SourceLocation];
  rparen_loc: SourceLocation;
  semicolon_loc: SourceLocation;
}

table EmptyDeclaration /* DeclarationAST */ {
  semicolon_loc: SourceLocation;
}

table AttributeDeclaration /* DeclarationAST */ {
  attribute_list: [Attribute];
  semicolon_loc: SourceLocation;
}

table OpaqueEnumDeclaration /* DeclarationAST */ {
  attribute_list: [Attribute];
  nested_name_specifier: NestedNameSpecifier;
  name: Name;
  enum_base: EnumBase;
  enum_loc: SourceLocation;
  class_loc: SourceLocation;
  emicolon_loc: SourceLocation;
}

table UsingEnumDeclaration /* DeclarationAST */ {
}

table NamespaceDefinition /* DeclarationAST */ {
  attribute_list: [Attribute];
  nested_name_specifier: NestedNameSpecifier;
  name: Name;
  extra_attribute_list: [Attribute];
  declaration_list: [Declaration];
  inline_loc: SourceLocation;
  namespace_loc: SourceLocation;
  lbrace_loc: SourceLocation;
  rbrace_loc: SourceLocation;
}

table NamespaceAliasDefinition /* DeclarationAST */ {
  nested_name_specifier: NestedNameSpecifier;
  name: Name;
  identifier: string;
  namespace_loc: SourceLocation;
  identifier_loc: SourceLocation;
  equal_loc: SourceLocation;
  semicolon_loc: SourceLocation;
}

table UsingDirective /* DeclarationAST */ {
  attribute_list: [Attribute];
  nested_name_specifier: NestedNameSpecifier;
  name: Name;
  using_loc: SourceLocation;
  namespace_loc: SourceLocation;
  semicolon_loc: SourceLocation;
}

table UsingDeclaration /* DeclarationAST */ {
  using_declarator_list: [UsingDeclarator];
  using_loc: SourceLocation;
  semicolon_loc: SourceLocation;
}

table AsmDeclaration /* DeclarationAST */ {
  attribute_list: [Attribute];
  asm_loc: SourceLocation;
  lparen_loc: SourceLocation;
  string_literal_list: [SourceLocation];
  rparen_loc: SourceLocation;
  semicolon_loc: SourceLocation;
}

table ExportDeclaration /* DeclarationAST */ {
  declaration: Declaration;
  export_loc: SourceLocation;
}

table ExportCompoundDeclaration /* DeclarationAST */ {
  declaration_list: [Declaration];
  export_loc: SourceLocation;
  lbrace_loc: SourceLocation;
  rbrace_loc: SourceLocation;
}

table ModuleImportDeclaration /* DeclarationAST */ {
  import_name: ImportName;
  attribute_list: [Attribute];
  import_loc: SourceLocation;
  semicolon_loc: SourceLocation;
}

table TemplateDeclaration /* DeclarationAST */ {
  template_parameter_list: [Declaration];
  requires_clause: RequiresClause;
  declaration: Declaration;
  template_loc: SourceLocation;
  less_loc: SourceLocation;
  greater_loc: SourceLocation;
}

table TypenameTypeParameter /* DeclarationAST */ {
  type_id: TypeId;
  identifier: string;
  class_key_loc: SourceLocation;
  ellipsis_loc: SourceLocation;
  identifier_loc: SourceLocation;
  equal_loc: SourceLocation;
}

table TemplateTypeParameter /* DeclarationAST */ {
  template_parameter_list: [Declaration];
  requires_clause: RequiresClause;
  name: Name;
  identifier: string;
  template_loc: SourceLocation;
  less_loc: SourceLocation;
  greater_loc: SourceLocation;
  class_key_loc: SourceLocation;
  identifier_loc: SourceLocation;
  equal_loc: SourceLocation;
}

table TemplatePackTypeParameter /* DeclarationAST */ {
  template_parameter_list: [Declaration];
  identifier: string;
  template_loc: SourceLocation;
  less_loc: SourceLocation;
  greater_loc: SourceLocation;
  class_key_loc: SourceLocation;
  ellipsis_loc: SourceLocation;
  identifier_loc: SourceLocation;
}

table DeductionGuide /* DeclarationAST */ {
}

table ExplicitInstantiation /* DeclarationAST */ {
  declaration: Declaration;
  extern_loc: SourceLocation;
  template_loc: SourceLocation;
}

table ParameterDeclaration /* DeclarationAST */ {
  attribute_list: [Attribute];
  type_specifier_list: [Specifier];
  declarator: Declarator;
  expression: Expression;
  equal_loc: SourceLocation;
}

table LinkageSpecification /* DeclarationAST */ {
  declaration_list: [Declaration];
  string_literal: string;
  extern_loc: SourceLocation;
  stringliteral_loc: SourceLocation;
  lbrace_loc: SourceLocation;
  rbrace_loc: SourceLocation;
}

table FunctionDeclarator /* DeclaratorModifierAST */ {
  parameters_and_qualifiers: ParametersAndQualifiers;
  trailing_return_type: TrailingReturnType;
}

table ArrayDeclarator /* DeclaratorModifierAST */ {
  expression: Expression;
  attribute_list: [Attribute];
  lbracket_loc: SourceLocation;
  rbracket_loc: SourceLocation;
}

table EllipsisExceptionDeclaration /* ExceptionDeclarationAST */ {
  ellipsis_loc: SourceLocation;
}

table TypeExceptionDeclaration /* ExceptionDeclarationAST */ {
  attribute_list: [Attribute];
  type_specifier_list: [Specifier];
  declarator: Declarator;
}

table ThisExpression /* ExpressionAST */ {
  this_loc: SourceLocation;
}

table CharLiteralExpression /* ExpressionAST */ {
  literal: string;
  literal_loc: SourceLocation;
}

table BoolLiteralExpression /* ExpressionAST */ {
  literal: uint32;
  literal_loc: SourceLocation;
}

table IntLiteralExpression /* ExpressionAST */ {
  literal: string;
  literal_loc: SourceLocation;
}

table FloatLiteralExpression /* ExpressionAST */ {
  literal: string;
  literal_loc: SourceLocation;
}

table NullptrLiteralExpression /* ExpressionAST */ {
  literal: uint32;
  literal_loc: SourceLocation;
}

table StringLiteralExpression /* ExpressionAST */ {
  literal: string;
  string_literal_list: [SourceLocation];
}

table UserDefinedStringLiteralExpression /* ExpressionAST */ {
  literal: string;
  literal_loc: SourceLocation;
}

table IdExpression /* ExpressionAST */ {
  name: Name;
}

table RequiresExpression /* ExpressionAST */ {
  parameter_declaration_clause: ParameterDeclarationClause;
  requirement_body: RequirementBody;
  requires_loc: SourceLocation;
  lparen_loc: SourceLocation;
  rparen_loc: SourceLocation;
}

table NestedExpression /* ExpressionAST */ {
  expression: Expression;
  lparen_loc: SourceLocation;
  rparen_loc: SourceLocation;
}

table RightFoldExpression /* ExpressionAST */ {
  expression: Expression;
  op: uint32;
  lparen_loc: SourceLocation;
  op_loc: SourceLocation;
  ellipsis_loc: SourceLocation;
  rparen_loc: SourceLocation;
}

table LeftFoldExpression /* ExpressionAST */ {
  expression: Expression;
  op: uint32;
  lparen_loc: SourceLocation;
  ellipsis_loc: SourceLocation;
  op_loc: SourceLocation;
  rparen_loc: SourceLocation;
}

table FoldExpression /* ExpressionAST */ {
  left_expression: Expression;
  right_expression: Expression;
  op: uint32;
  fold_op: uint32;
  lparen_loc: SourceLocation;
  op_loc: SourceLocation;
  ellipsis_loc: SourceLocation;
  fold_op_loc: SourceLocation;
  rparen_loc: SourceLocation;
}

table LambdaExpression /* ExpressionAST */ {
  lambda_introducer: LambdaIntroducer;
  template_parameter_list: [Declaration];
  requires_clause: RequiresClause;
  lambda_declarator: LambdaDeclarator;
  statement: CompoundStatement;
  less_loc: SourceLocation;
  greater_loc: SourceLocation;
}

table SizeofExpression /* ExpressionAST */ {
  expression: Expression;
  sizeof_loc: SourceLocation;
}

table SizeofTypeExpression /* ExpressionAST */ {
  type_id: TypeId;
  sizeof_loc: SourceLocation;
  lparen_loc: SourceLocation;
  rparen_loc: SourceLocation;
}

table SizeofPackExpression /* ExpressionAST */ {
  identifier: string;
  sizeof_loc: SourceLocation;
  ellipsis_loc: SourceLocation;
  lparen_loc: SourceLocation;
  identifier_loc: SourceLocation;
  rparen_loc: SourceLocation;
}

table TypeidExpression /* ExpressionAST */ {
  expression: Expression;
  typeid_loc: SourceLocation;
  lparen_loc: SourceLocation;
  rparen_loc: SourceLocation;
}

table TypeidOfTypeExpression /* ExpressionAST */ {
  type_id: TypeId;
  typeid_loc: SourceLocation;
  lparen_loc: SourceLocation;
  rparen_loc: SourceLocation;
}

table AlignofExpression /* ExpressionAST */ {
  type_id: TypeId;
  alignof_loc: SourceLocation;
  lparen_loc: SourceLocation;
  rparen_loc: SourceLocation;
}

table TypeTraitsExpression /* ExpressionAST */ {
  type_id_list: [TypeId];
  type_traits: uint32;
  type_traits_loc: SourceLocation;
  lparen_loc: SourceLocation;
  rparen_loc: SourceLocation;
}

table UnaryExpression /* ExpressionAST */ {
  expression: Expression;
  op: uint32;
  op_loc: SourceLocation;
}

table BinaryExpression /* ExpressionAST */ {
  left_expression: Expression;
  right_expression: Expression;
  op: uint32;
  op_loc: SourceLocation;
}

table AssignmentExpression /* ExpressionAST */ {
  left_expression: Expression;
  right_expression: Expression;
  op: uint32;
  op_loc: SourceLocation;
}

table BracedTypeConstruction /* ExpressionAST */ {
  type_specifier: Specifier;
  braced_init_list: BracedInitList;
}

table TypeConstruction /* ExpressionAST */ {
  type_specifier: Specifier;
  expression_list: [Expression];
  lparen_loc: SourceLocation;
  rparen_loc: SourceLocation;
}

table CallExpression /* ExpressionAST */ {
  base_expression: Expression;
  expression_list: [Expression];
  lparen_loc: SourceLocation;
  rparen_loc: SourceLocation;
}

table SubscriptExpression /* ExpressionAST */ {
  base_expression: Expression;
  index_expression: Expression;
  lbracket_loc: SourceLocation;
  rbracket_loc: SourceLocation;
}

table MemberExpression /* ExpressionAST */ {
  base_expression: Expression;
  name: Name;
  access_op: uint32;
  access_loc: SourceLocation;
  template_loc: SourceLocation;
}

table PostIncrExpression /* ExpressionAST */ {
  base_expression: Expression;
  op: uint32;
  op_loc: SourceLocation;
}

table ConditionalExpression /* ExpressionAST */ {
  condition: Expression;
  iftrue_expression: Expression;
  iffalse_expression: Expression;
  question_loc: SourceLocation;
  colon_loc: SourceLocation;
}

table ImplicitCastExpression /* ExpressionAST */ {
  expression: Expression;
}

table CastExpression /* ExpressionAST */ {
  type_id: TypeId;
  expression: Expression;
  lparen_loc: SourceLocation;
  rparen_loc: SourceLocation;
}

table CppCastExpression /* ExpressionAST */ {
  type_id: TypeId;
  expression: Expression;
  cast_loc: SourceLocation;
  less_loc: SourceLocation;
  greater_loc: SourceLocation;
  lparen_loc: SourceLocation;
  rparen_loc: SourceLocation;
}

table NewExpression /* ExpressionAST */ {
  type_id: NewTypeId;
  new_initalizer: NewInitializer;
  scope_loc: SourceLocation;
  new_loc: SourceLocation;
}

table DeleteExpression /* ExpressionAST */ {
  expression: Expression;
  scope_loc: SourceLocation;
  delete_loc: SourceLocation;
  lbracket_loc: SourceLocation;
  rbracket_loc: SourceLocation;
}

table ThrowExpression /* ExpressionAST */ {
  expression: Expression;
  throw_loc: SourceLocation;
}

table NoexceptExpression /* ExpressionAST */ {
  expression: Expression;
  noexcept_loc: SourceLocation;
  lparen_loc: SourceLocation;
  rparen_loc: SourceLocation;
}

table DefaultFunctionBody /* FunctionBodyAST */ {
  equal_loc: SourceLocation;
  default_loc: SourceLocation;
  semicolon_loc: SourceLocation;
}

table CompoundStatementFunctionBody /* FunctionBodyAST */ {
  ctor_initializer: CtorInitializer;
  statement: CompoundStatement;
}

table TryStatementFunctionBody /* FunctionBodyAST */ {
  ctor_initializer: CtorInitializer;
  statement: CompoundStatement;
  handler_list: [Handler];
  try_loc: SourceLocation;
}

table DeleteFunctionBody /* FunctionBodyAST */ {
  equal_loc: SourceLocation;
  delete_loc: SourceLocation;
  semicolon_loc: SourceLocation;
}

table EqualInitializer /* InitializerAST */ {
  expression: Expression;
  equal_loc: SourceLocation;
}

table BracedInitList /* InitializerAST */ {
  expression_list: [Expression];
  lbrace_loc: SourceLocation;
  comma_loc: SourceLocation;
  rbrace_loc: SourceLocation;
}

table ParenInitializer /* InitializerAST */ {
  expression_list: [Expression];
  lparen_loc: SourceLocation;
  rparen_loc: SourceLocation;
}

table ThisLambdaCapture /* LambdaCaptureAST */ {
  this_loc: SourceLocation;
}

table DerefThisLambdaCapture /* LambdaCaptureAST */ {
  star_loc: SourceLocation;
  this_loc: SourceLocation;
}

table SimpleLambdaCapture /* LambdaCaptureAST */ {
  identifier: string;
  identifier_loc: SourceLocation;
  ellipsis_loc: SourceLocation;
}

table RefLambdaCapture /* LambdaCaptureAST */ {
  identifier: string;
  amp_loc: SourceLocation;
  identifier_loc: SourceLocation;
  ellipsis_loc: SourceLocation;
}

table RefInitLambdaCapture /* LambdaCaptureAST */ {
  initializer: Initializer;
  identifier: string;
  amp_loc: SourceLocation;
  ellipsis_loc: SourceLocation;
  identifier_loc: SourceLocation;
}

table InitLambdaCapture /* LambdaCaptureAST */ {
  initializer: Initializer;
  identifier: string;
  ellipsis_loc: SourceLocation;
  identifier_loc: SourceLocation;
}

table ParenMemInitializer /* MemInitializerAST */ {
  name: Name;
  expression_list: [Expression];
  lparen_loc: SourceLocation;
  rparen_loc: SourceLocation;
  ellipsis_loc: SourceLocation;
}

table BracedMemInitializer /* MemInitializerAST */ {
  name: Name;
  braced_init_list: BracedInitList;
  ellipsis_loc: SourceLocation;
}

table SimpleName /* NameAST */ {
  identifier: string;
  identifier_loc: SourceLocation;
}

table DestructorName /* NameAST */ {
  id: Name;
  tilde_loc: SourceLocation;
}

table DecltypeName /* NameAST */ {
  decltype_specifier: Specifier;
}

table OperatorName /* NameAST */ {
  op: uint32;
  operator_loc: SourceLocation;
  op_loc: SourceLocation;
  open_loc: SourceLocation;
  close_loc: SourceLocation;
}

table ConversionName /* NameAST */ {
  type_id: TypeId;
  operator_loc: SourceLocation;
}

table TemplateName /* NameAST */ {
  id: Name;
  template_argument_list: [TemplateArgument];
  less_loc: SourceLocation;
  greater_loc: SourceLocation;
}

table QualifiedName /* NameAST */ {
  nested_name_specifier: NestedNameSpecifier;
  id: Name;
  template_loc: SourceLocation;
}

table NewParenInitializer /* NewInitializerAST */ {
  expression_list: [Expression];
  lparen_loc: SourceLocation;
  rparen_loc: SourceLocation;
}

table NewBracedInitializer /* NewInitializerAST */ {
  braced_init: BracedInitList;
}

table PointerOperator /* PtrOperatorAST */ {
  attribute_list: [Attribute];
  cv_qualifier_list: [Specifier];
  star_loc: SourceLocation;
}

table ReferenceOperator /* PtrOperatorAST */ {
  attribute_list: [Attribute];
  ref_op: uint32;
  ref_loc: SourceLocation;
}

table PtrToMemberOperator /* PtrOperatorAST */ {
  nested_name_specifier: NestedNameSpecifier;
  attribute_list: [Attribute];
  cv_qualifier_list: [Specifier];
  star_loc: SourceLocation;
}

table SimpleRequirement /* RequirementAST */ {
  expression: Expression;
  semicolon_loc: SourceLocation;
}

table CompoundRequirement /* RequirementAST */ {
  expression: Expression;
  type_constraint: TypeConstraint;
  lbrace_loc: SourceLocation;
  rbrace_loc: SourceLocation;
  noexcept_loc: SourceLocation;
  minus_greater_loc: SourceLocation;
  semicolon_loc: SourceLocation;
}

table TypeRequirement /* RequirementAST */ {
  nested_name_specifier: NestedNameSpecifier;
  name: Name;
  typename_loc: SourceLocation;
  semicolon_loc: SourceLocation;
}

table NestedRequirement /* RequirementAST */ {
  expression: Expression;
  requires_loc: SourceLocation;
  semicolon_loc: SourceLocation;
}

table TypedefSpecifier /* SpecifierAST */ {
  typedef_loc: SourceLocation;
}

table FriendSpecifier /* SpecifierAST */ {
  friend_loc: SourceLocation;
}

table ConstevalSpecifier /* SpecifierAST */ {
  consteval_loc: SourceLocation;
}

table ConstinitSpecifier /* SpecifierAST */ {
  constinit_loc: SourceLocation;
}

table ConstexprSpecifier /* SpecifierAST */ {
  constexpr_loc: SourceLocation;
}

table InlineSpecifier /* SpecifierAST */ {
  inline_loc: SourceLocation;
}

table StaticSpecifier /* SpecifierAST */ {
  static_loc: SourceLocation;
}

table ExternSpecifier /* SpecifierAST */ {
  extern_loc: SourceLocation;
}

table ThreadLocalSpecifier /* SpecifierAST */ {
  thread_local_loc: SourceLocation;
}

table ThreadSpecifier /* SpecifierAST */ {
  thread_loc: SourceLocation;
}

table MutableSpecifier /* SpecifierAST */ {
  mutable_loc: SourceLocation;
}

table VirtualSpecifier /* SpecifierAST */ {
  virtual_loc: SourceLocation;
}

table ExplicitSpecifier /* SpecifierAST */ {
  expression: Expression;
  explicit_loc: SourceLocation;
  lparen_loc: SourceLocation;
  rparen_loc: SourceLocation;
}

table AutoTypeSpecifier /* SpecifierAST */ {
  auto_loc: SourceLocation;
}

table VoidTypeSpecifier /* SpecifierAST */ {
  void_loc: SourceLocation;
}

table VaListTypeSpecifier /* SpecifierAST */ {
  specifier: uint32;
  specifier_loc: SourceLocation;
}

table IntegralTypeSpecifier /* SpecifierAST */ {
  specifier: uint32;
  specifier_loc: SourceLocation;
}

table FloatingPointTypeSpecifier /* SpecifierAST */ {
  specifier: uint32;
  specifier_loc: SourceLocation;
}

table ComplexTypeSpecifier /* SpecifierAST */ {
  complex_loc: SourceLocation;
}

table NamedTypeSpecifier /* SpecifierAST */ {
  name: Name;
}

table AtomicTypeSpecifier /* SpecifierAST */ {
  type_id: TypeId;
  atomic_loc: SourceLocation;
  lparen_loc: SourceLocation;
  rparen_loc: SourceLocation;
}

table UnderlyingTypeSpecifier /* SpecifierAST */ {
}

table ElaboratedTypeSpecifier /* SpecifierAST */ {
  attribute_list: [Attribute];
  nested_name_specifier: NestedNameSpecifier;
  name: Name;
  class_loc: SourceLocation;
}

table DecltypeAutoSpecifier /* SpecifierAST */ {
  decltype_loc: SourceLocation;
  lparen_loc: SourceLocation;
  auto_loc: SourceLocation;
  rparen_loc: SourceLocation;
}

table DecltypeSpecifier /* SpecifierAST */ {
  expression: Expression;
  decltype_loc: SourceLocation;
  lparen_loc: SourceLocation;
  rparen_loc: SourceLocation;
}

table PlaceholderTypeSpecifier /* SpecifierAST */ {
  type_constraint: TypeConstraint;
  specifier: Specifier;
}

table ConstQualifier /* SpecifierAST */ {
  const_loc: SourceLocation;
}

table VolatileQualifier /* SpecifierAST */ {
  volatile_loc: SourceLocation;
}

table RestrictQualifier /* SpecifierAST */ {
  restrict_loc: SourceLocation;
}

table EnumSpecifier /* SpecifierAST */ {
  attribute_list: [Attribute];
  nested_name_specifier: NestedNameSpecifier;
  name: Name;
  enum_base: EnumBase;
  enumerator_list: [Enumerator];
  enum_loc: SourceLocation;
  class_loc: SourceLocation;
  lbrace_loc: SourceLocation;
  comma_loc: SourceLocation;
  rbrace_loc: SourceLocation;
}

table ClassSpecifier /* SpecifierAST */ {
  attribute_list: [Attribute];
  name: Name;
  base_clause: BaseClause;
  declaration_list: [Declaration];
  class_loc: SourceLocation;
  lbrace_loc: SourceLocation;
  rbrace_loc: SourceLocation;
}

table TypenameSpecifier /* SpecifierAST */ {
  nested_name_specifier: NestedNameSpecifier;
  name: Name;
  typename_loc: SourceLocation;
}

table LabeledStatement /* StatementAST */ {
  statement: Statement;
  identifier: string;
  identifier_loc: SourceLocation;
  colon_loc: SourceLocation;
}

table CaseStatement /* StatementAST */ {
  expression: Expression;
  statement: Statement;
  case_loc: SourceLocation;
  colon_loc: SourceLocation;
}

table DefaultStatement /* StatementAST */ {
  statement: Statement;
  default_loc: SourceLocation;
  colon_loc: SourceLocation;
}

table ExpressionStatement /* StatementAST */ {
  expression: Expression;
  semicolon_loc: SourceLocation;
}

table CompoundStatement /* StatementAST */ {
  statement_list: [Statement];
  lbrace_loc: SourceLocation;
  rbrace_loc: SourceLocation;
}

table IfStatement /* StatementAST */ {
  initializer: Statement;
  condition: Expression;
  statement: Statement;
  else_statement: Statement;
  if_loc: SourceLocation;
  constexpr_loc: SourceLocation;
  lparen_loc: SourceLocation;
  rparen_loc: SourceLocation;
}

table SwitchStatement /* StatementAST */ {
  initializer: Statement;
  condition: Expression;
  statement: Statement;
  switch_loc: SourceLocation;
  lparen_loc: SourceLocation;
  rparen_loc: SourceLocation;
}

table WhileStatement /* StatementAST */ {
  condition: Expression;
  statement: Statement;
  while_loc: SourceLocation;
  lparen_loc: SourceLocation;
  rparen_loc: SourceLocation;
}

table DoStatement /* StatementAST */ {
  statement: Statement;
  expression: Expression;
  do_loc: SourceLocation;
  while_loc: SourceLocation;
  lparen_loc: SourceLocation;
  rparen_loc: SourceLocation;
  semicolon_loc: SourceLocation;
}

table ForRangeStatement /* StatementAST */ {
  initializer: Statement;
  range_declaration: Declaration;
  range_initializer: Expression;
  statement: Statement;
  for_loc: SourceLocation;
  lparen_loc: SourceLocation;
  colon_loc: SourceLocation;
  rparen_loc: SourceLocation;
}

table ForStatement /* StatementAST */ {
  initializer: Statement;
  condition: Expression;
  expression: Expression;
  statement: Statement;
  for_loc: SourceLocation;
  lparen_loc: SourceLocation;
  semicolon_loc: SourceLocation;
  rparen_loc: SourceLocation;
}

table BreakStatement /* StatementAST */ {
  break_loc: SourceLocation;
  semicolon_loc: SourceLocation;
}

table ContinueStatement /* StatementAST */ {
  continue_loc: SourceLocation;
  semicolon_loc: SourceLocation;
}

table ReturnStatement /* StatementAST */ {
  expression: Expression;
  return_loc: SourceLocation;
  semicolon_loc: SourceLocation;
}

table GotoStatement /* StatementAST */ {
  identifier: string;
  goto_loc: SourceLocation;
  identifier_loc: SourceLocation;
  semicolon_loc: SourceLocation;
}

table CoroutineReturnStatement /* StatementAST */ {
  expression: Expression;
  coreturn_loc: SourceLocation;
  semicolon_loc: SourceLocation;
}

table DeclarationStatement /* StatementAST */ {
  declaration: Declaration;
}

table TryBlockStatement /* StatementAST */ {
  statement: CompoundStatement;
  handler_list: [Handler];
  try_loc: SourceLocation;
}

table TypeTemplateArgument /* TemplateArgumentAST */ {
  type_id: TypeId;
}

table ExpressionTemplateArgument /* TemplateArgumentAST */ {
  expression: Expression;
}

table TranslationUnit /* UnitAST */ {
  declaration_list: [Declaration];
}

table ModuleUnit /* UnitAST */ {
  global_module_fragment: GlobalModuleFragment;
  module_declaration: ModuleDeclaration;
  declaration_list: [Declaration];
  private_module_fragment: PrivateModuleFragment;
}


table SerializedUnit {
  version: uint32;
  unit: Unit;
  file_name: string;
}

root_type SerializedUnit;
file_identifier "AST0";
file_extension "ast";
